# Meta4d.me Interface Doc

## M4M Components

### Prepare New Component

method: post

url: /api/v1/component/generate

params:

```
{
  "chain_name": "",
  // code of equipment, should be string of number
  "component_id": "",
  "description": "xxx xxx xxx",
  // full name of component
  "name": "",
  // abbrevation of name
  "symbol": "",
  // ipfs hash
  "uri": "",
  // previous ipfs hash
  "prev": "",
  // attributes that compliant Opense
  "attrs": [
    {},
    {}
  ],
  "sig": ""
}
```

> sig = signer.signMessage(component_id), component_id should be string

> there must be position trait type in attrs

returns:

```json
{
  "code": "",
  "error": "",
  "data": {
    "tx_hash": "0x2222213131313121212123132123121231321323321131332131321213"
  }
}
```

> return tx hash so that web3 could listen tx

### Get Component Status

method: get

url: /api/v1/component/status/:chain_name/:component_id

returns:

```json
{
  "code": "",
  "error": "",
  "data": {
    "status": 1
  }
}
```

| status | desc                       |
|--------|----------------------------|
| 0      | pending, wait tx confirmed |
| 1      | success, created           |

### Claim Loot

method: post

url: /api/v1/component/claim

params:

```json
{
  "chain_name": "",
  "addr": "0x12121212121212121212121212121212121222",
  "uuid": "11111aaaaaaaa",
  "component_id": [
    1,
    2,
    3,
    4
  ],
  "component_nums": [
    1,
    2,
    3,
    4
  ],
  "sig": ""
}
```

> note: uuid is unique identifier for each user in each game

> note: sig = signer.signMessage(uuid), uuid should be string

return:

```json
{
  "code": "",
  "error": "",
  "data": {
    "sig": "0x12ad12da12da12da12da12d1a2da121da2d1a2d1a21da21d2a1d2a1d2a1d2a1d2a1d2a1d2a1d2a1d2a1d21a"
  }
}
```

## M4M-NFT

### Bind M4M NFT Metadata

bind metadata to m4m-nft

> note: attrs generated by nft owned components, cannot set by post request

url: /api/v1/m4m-nft/bind-metadata

method: post

params:

```json
{
  "chain_name": "",
  "m4m_token_id": "",
  "prev": "",
  "description": "xxx xxx xxx",
  "name": "",
  "uri": "",
  "sig": ""
}
```

> note: sig = signer.signMessage(m4m_token_id), m4m_token_id should be string

return:

```json
{
  "code": "",
  "error": "",
  "data": {}
}
```

### Bind M4M Components Metadata

bind metadata to component, only bind once

> note: components should be generated throw [prepare new component](#prepare-new-component), but we
> provide `prepareAndMint` method at M4mComponentV2 contracts, so backend should support bind metadata for component.

url: /api/v1/component/bind-metadata

method: post

params:

```json
{
  "chain_name": "",
  "component_id": "",
  "prev": "",
  "description": "xxx xxx xxx",
  "name": "",
  "uri": "",
  "attrs": [
    {},
    {}
  ],
  "sig": ""
}
```

> note: sig = signer.signMessage(component_id), m4m_token_id should be string

return:

```json
{
  "code": "",
  "error": "",
  "data": {}
}
```

### Get Initialization Params

method: get

url: /api/v1/m4m-nft/initialization?original_addr=xxx&&original_token_id=xxx&&chain_name=xxx

> original_addr: contract address of parsed nft
>
> original_token_id: token id of parsed nft

return:

```json
{
  "code": "",
  "error": "",
  "data": [
    {
      "m4m_token_id": "81449136432453593952252541924876232285909669905506625386482230805063052117465",
      "component_ids": "1,2,3,4",
      "component_nums": "2,3,3,4",
      "sig": "0x12ad12da12da12da12da12d1a2da121da2d1a2d1a21da21d2a1d2a1d2a1d2a1d2a1d2a1d2a1d2a1d2a1d21a"
    }
  ]
}
```

> m4m_token_id: token id of m4m NFT
>
> m4m_token_id is type of u256
>
> m4m_token_id = ethers.BigNumber.from(ethers.utils.solidityKeccak256(['bytes'],[
> ethers.utils.solidityPack(['address', 'uint'], [simpleNFT.address, simpleNFTId])]));

#### how to generate m4m_token_id off chain

```js
let originalNFTAddr = '0x1212121'; // configured value
let originalTokenId = 123; // parsed original nft token id, should query it on chian
let hash = ethers.utils.solidityKeccak256(['bytes'],
    [ethers.utils.solidityPack(['address', 'uint'], [originalNFTAddr, originalTokenId])]);
let m4mNFTId = ethers.BigNumber.from(hash);
```

> note: originalTokenId should be queried from on-chain contract originalNFT.tokenIndex(), and this value would
> increment 1 after each mint

### Get M4M-NFT Attrs

method: get

url: /api/v1/m4m-nft/attrs?m4m_token_id=xxx&&chain_name=xxx

return:

```json
{
  "code": "",
  "error": "",
  "data": [
    {
      "m4m_token_id": "81449136432453593952252541924876232285909669905506625386482230805063052117465",
      "chain_name": "xxx",
      "component_ids": "1,2,3,4",
      "component_nums": "2,3,3,4"
    }
  ]
}
```

> note: No authentication temporary

## Metadata

### Get Metadata

Return the metadata, compliant with opensea

> refer: https://docs.opensea.io/docs/metadata-standards

method: get

url: /api/tokenuri/:contract/:token_id

> example: https://api.meta4d.me/api/tokenuri/0xb6bb4812a8e075cbad0128e318203553c4ca463d/0

return:

```json
{
  "description": "xxx xxx xxx",
  "external_url": "https://www.meta4d.me/",
  "image": "https://ipfs.io/.....",
  "name": "M4M NFT XXXX",
  "attributes": [
    {},
    {},
    {}
  ]
}
```

## Query Interface

### Query NFT

method: get

url: api/v1/nfts?chain_name=xxx&addr=xxx&contract=xxx&token_id=xxx&page=xxx&gap=xxx

> note: chain_name is required, addr or contract is required, token_id is optional

return:

```
{
  "code": "",
  "error": "",
  "data": {
      "total": 10000,
      "data": [
        {
          "contract": "",
          "erc": "", // 1155 or 721
          "token_id": "",
          "amount": "",
          "uri": "",
          "owner": ""
        }
      ]
  }
}
```

### Query Collection List of User

method: get

url: /api/v1/collection/list?chain_name=xxx&addr=xxx&page=xxx&gap=xxx

> addr and chain_name are required

return:

```
{
  "code": "",
  "error": "",
  "data": {
    "total": 10000, 
    "data": [
      {
        "chain_name":["mainnet"],
        "id": "aaaa",
        "name": "collection 1",
        "img": ""
      },
      {
        "chain_name":["mainnet","polygon"],
        "id": "aaaa",
        "name": "collection 2",
        "img": ""
      }
    ]
  }
}
```

### Query NFT by Collection

method: get

url: api/v1/collection/nfts?chain_name=xxx&collection_id=xxx&addr=xxx&page=xxx&gap=xxx

> note: collection_id and chain_name is required; addr is user address, is optional

return:

```
{
  "code": "",
  "error": "",
  "data": {
      "collection_id": "",
      "collection_name": "",
      "collection_img": "",
      "total": 10000,
      "data": [
        {
          "contract": "",
          "erc": "",
          "token_id": "",
          "amount": "",
          "uri": "",
          "owner": ""
        }
      ]
  }
}
```

## Return Value

uniform return:

```json
{
  "code": "",
  "error": "",
  "data": {}
}
```

### code

`code=0` means that success, others is failed。

### error

when `code!=0`, return error info。

### data

response result.
